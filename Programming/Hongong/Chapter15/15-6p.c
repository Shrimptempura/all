/*
2차원 배열 요소의 두 가지 의미
int ary[3][4];
- 2차원 배열 ary의 논리적 배열 요소의 개수는? 3개
- 2차원 배열 ary의 물리적 배열 요소의 개수는 ? 12개

개념적으로 2차원 배열의 요소는 1차원 배열이지만, 실제로 데이터가 저장되는 공간은
1차원 배열의 요소이다. <따라서> 2차원 배열에서 '배열 요소'는 논리적으로는 1차원의
부분배열을 뜻하고, 물리적으로는 실제 데이터를 저장하는 부분배열의 요소를 뜻한다.
    2차원 배열 = 논리적) 1차원의 부분배열
                물리적) 실제 데이터를 저장하는 부분배열의 요소

<2차원 배열의 요소를 참조하는 원리>
2차원 배열은 1차원 배열과 같이 모든 저장 공간이 메모리에 연속으로 할당됨.
이 공간을 2차원의 논리적 공간으로 사용할 수 있는 것은 '배열명'이 1차원 배열의 주소로
1차원 배열 전체를 가리키기 때문. <따라서> 배열 포인터를 쓰면 1차원의 물리적 공간을
2차원의 논리적 구조로 사용할 수 있다.

2차원 배열 int ary[3][4];가 1~12 초기화 및 할당되었을때 7번째 물리적 요소 참조과정확인
7번째 물리적 요소는 두번재 부분배열 ary[1]에 속하므로, 먼저 ary[1]의 시작위치를 구함.
2차원 배열 ary는 첫 번째 부분배열의 주소이므로 ary에 1을 더하면 두번째 부분배열
ary[1]의 주소를 구할수 있다.

ary + 1 ==> 100 + (1 * sizeof(ary[0])) ==> 100 + (1 * 16) ==> 116

<여기서> 쉽게 생각하면 116번지에 2를 더하면 7이 나오지 않을까?
1   2   3   4
5   6   7   8
9   10  11  12
2를 더해 7번째 물리적 배열 요소의 위치를 구할꺼 같지만!
<그러나> (ary + 1) + 2의 값은 ary + 3이 되므로 계산 규칙에 따라 148번지가 된다.

ary + 1의 결과인 116번지는 두 번째 부분배열 전체를 가리키는 주소이다. 
<즉>, 주소 ary에 정수를 더한 값도 '주소'며 가리키는 자료형도 변하지 않는다.
<따라서> 116번지에 '간접 참조 연산자'를 사용하여 두 번째 부분배열을 구하는 과정 필요!

*(ary + 1) ==> ary[1]   // 두 번째 부분배열

부분배열명 ary[1]은 다시 두 번째 부분배열의 첫 번째 주소로 쓸수 있다.
<즉>, *(ary + 1)의 연산 결과는 다섯 번째 물리적 요소의 주소가 된다.
이제 여기에 2를 더하면 124번지를 구할 수 있다.

*(ary + 1) + 2 ==> *(ary + 1) + (2 * sizeof(ary[1][0])) ==> 116 + (2 * 4) ==> 124
                sizeof(ary[1][0]) = 두 번째 부분배열의 첫번째 배열 요소의 크기

연산의 결과값 124번지는 7번째 물리적 배열 요소의 주소입니다. <따라서>
그 요소를 쓰기 위해서는 마지막으로 간접 참조 연산을 수행합니다.
*(*(ary + 1) + 2) ==> ary[1][2]     // 두 번째 부분배열의 세 번째 요소

<결국> 첫 번째 부분배열의 주소인 ary를 사용하면 배열의 모든 공간과 값을 사용할수있다.
<같은> 원리로 ary를 배열 포인터에 저장하면 배열 포인터를 배열처럼 쓰는 것이 가능해짐

2차원 배열 int ary[3][4];
&ary        // 2차원 배열 전체의 주소
ary         // 첫 번째 부분배열의 주소
&ary[0]     // 첫 번째 부분배열의 주소 
ary[0]      // 첫 번째 부분배열의 첫 번째 배열 요소의 주소
&ary[0][0]  // 첫 번째 부분배열의 첫 번째 배열 요소의 주소

sizeof(ary)         // 배열 전체의 크기 48바이트
sizeof(&ary[0])     // 주소의 크기 4바이트
sizeof(ary[0])      // 부분배열 전체의 크기 16바이트
sizeof(&ary[0][0])  // 주소의 크기 바이트
*/

