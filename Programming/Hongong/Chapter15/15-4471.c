// 다음과 같이 선언된 함수가 있을때 대입 연산이 가능하도록 함수 포인터 선언하기
double div(int, int);
void prn(char *);
int *save(int);
                            // <함수 포인터 선언!>
double (*fpa)(int, int);
void (*fpb)(char *);         // 내가 쓴 오답 : void *fpb;
int *(*fpc)(int);

fpa = div;      // 1)의 대입연산
fpb = prn;      // 2)의 대입연산
fpc = save;     // 3)의 대입연산
/*
1. 함수 포인터 문제 다음처럼 생각하신 답이 맞습니다.
double (*fpa)(int, int);
void (*fpb)(char *);
int *(*fpc)(int);

2. int *save(int); 도 생각하신대로 정수 하나를 인수로 받고 주소를 반환하는
함수의 선언이 맞습니다. 어디의 주소를 반환할지는 함수의 정의 코드에서 결정해야 합니다. 
인수로 정수를 받으니 그 매개변수의 주소를 반환할 수도 있고 인수로 받은 값으로 연산을 
한 후에 그 결과를 함수 안의 별도의 변수에 저장하고 그 주소를 반환할 수도 있고 
전역변수의 주소를 반환할 수도 있겠지요. 문제에서는 함수의 원형에 맞는 함수를 
선언할 수 있는지를 묻는 것이며 함수 포인터를 정확히 사용한다면 서로 다른 기능의 
함수라도 같은 원형의 함수에 모두 사용할 수 있습니다.

3. int *(fpc)(int); 는 int *fpc(int); 와 같습니다. 그냥 주소를 반환하는 함수의 
선언입니다. int (*fpc)(int); 는 함수 포인터의 선언이므로 함수의 선언과 다르겠지요. 
fpc는 우리가 만든 단어인 식별자 인데요 그 것만 개별적으로 괄호를 치는 것은 의미가 
없습니다. 괄호는 연산의 우선 순위를 바꿀 때 주로 쓰는데요 선언에서도 컴파일러가 
연산자의 우선 순위에 따라 선언문을 해석한다고 보면 이해하기 편합니다. 
즉 int (*fpc)(int); 에서 괄호가 두 개 있는데요 첫번 째 괄호인 (*fpc)를 먼저 해석하여 
fpc가 포인터라고 결정합니다. 그리고 그 포인터가 가리키는 것이 (*fpc)를 제외한 나머지인데 
그 것이 int (int)인 것이죠. 즉 정수 하나를 인수로 받고 정수 하나를 반환하는 함수가 
되는 겁니다. int *fpc(int); 의 경우 fpc 앞에 있는 별(*)보다 뒤에 있는 괄호 (int)의 
우선 순위가 높으므로 fpc를 포인터로 해석하지 않고 함수로 먼저 해석합니다. 즉 fpc는
정수 하나를 받는 함수이고 그 반환값의 형태가 int * 형인 것이 됩니다. 따라서 fpc는 
함수이고 주소를 반환하는 함수가 되는 것이지요. 

++추가 설명
포인터는 기본 자료형을 응용하는 것이라 그 형태는 끝이 없고 따라서 모든 케이스를 
외워서 쓸수는 없다. 이렇때 연산자 우선순위를 따라 생각해보면 쉽다. double (*fpa)(int, int); 
의 경우 유일한 이름은 fda죠. fda를 기준으로 따져봅니다. fda앞에 *이 있으므로 일단 포인터가 됩니다. 
그 다음에 포인터가 가리키는 것이 무엇인지를 살펴보면 우측에 괄호가 있으므로 함수가 된다고 
생각하면 된다. int **(fpc)(int); 의 경우 fpc가 괄호로 묶여 있고 앞에 별이 없으므로 포인터가 
될수 없다. 물론 괄호 왼쪽에 별이 있지만 연산자 우선순위에서 괄호가 가장 높음으로 우측 괄호(int)를 
먼저 판단한다. 따라서 fpc는 함수다라고 판단한다. 그 함수의 매개변수는 int형 하나이고 반환형이 
int ** 인 이중포인터가 되는 것이죠. save 함수의 반환형이 int * 이므로 이 경우 반환형이 맞지 
않게 된다. 결론적으로 이름(식별자) 앞에 별이 붙지 않으면 포인터가 아니다. 공백은 있어도 된다.
    그럼 int *(*fpc)(int)를 int* (*fpc)(int)로 써도 된다.
*/

