// 주소는 가리키는 자료형이 일치하는 포인터에만 대입이 가능하다. <따라서> 가리키는
// 자료형이 다른 주소를 저장하는 경우라면 'void'포인터를 사용한다.
// void 포인터의 사용
#include <stdio.h>

int main(void)
{
    int a = 10;
    double b = 3.5;
    void *vp;       // void 포인터

    vp = &a;        // int형 변수의 주소 저장, a를 가리키는데 a는 int형 변수임.
    printf("a : %d\n", *(int *)vp);

    vp = &b;        // double형 변수의 주소 저장, b를 가리키는데 b는 double형 변수임.
    printf("b : %.1lf\n", *(double *)vp);

    return 0;
}
/* 10행에서 void 포인터를 선언, 변수명 앞에 '*'을 붙여 포인터임을 표시, 맨 앞에
void를 적음, void는 자료형을 결정하지 않겠다

void 포인터는 가리키는 자료형이 정해져 있지 않음으로 어떤 주소도 저장 가능하다.
<또한> 같은 이유로 간접 참조 연산이나 정수를 더하는 포인터 연산이 불가능
간접 참조 연산을 하려면 몇 바이트를 어떤 형태로 일거야 하는지 알아야 함.
<BUT> 어떤 주소가 올지 알 수 없으므로 연산이 불가능하다. 정수 연산도 마찬가지이다.

void 포인터를 사용할 때에는 원하는 형태로 변환하여 사용
printf("a : %d\n", *(int *)vp);  ==> (int *) 뜻은 int *로 형 변환

13행과 16행 모두 원래의 자료형에 맞게 void 포인터를 형 변환한다.
형 변환후 각각 가리키는 변수를 출력하기 위해 간접 참조 연산을 수행한다.
형 변환 연산자와 간접 참조 연산자는 모두 단항 연산자로서 우선순위가 같다.
이 경우 연산순서는 오른쪽부터 왼쪽으로 차례대로 연산한다.

*(int *)vp
1) vp -> (int *)    // vp를 (int *)형으로 변환
2) 1) - > *         // 변환된 vp가 가리키는 변수 참조

정수 연산 하는 법
14행에 printf("a의 주소 + 1의 값 : %d\n", (int *)vp + 1); 추가
==> int *형으로 변환된 void 포인터에 + 1 연산을 한 값이 출력된다.
물론 a의 주소 값보다 4가 큰 주소값이 출력된다.

sol) void 포인터가 형 변환을 하지 않는 경우도 있을까?
가능은 하지만 명시적으로 형 변환 대입이 좋다.
*/