// a+ 모드로 파일의 내용을 확인하며 출력
#include <stdio.h>
#include <string.h>

int main(void)
{
    FILE *fp;
    char str[20];

    fp = fopen("a.txt", "a+");      // 읽기 가능한 추가 모드로 개방
    if (fp == NULL)                 // 파일 개방 확인
    {
        printf("파일을 만들지 못했습니다.\n");
        return 1;
    }

    while (1)
    {
        printf("과일 이름 : ");
        scanf("%s", str);                   // 키보드로 과일 이름 입력
        if (strcmp(str, "end") == 0)        // end 입력시 종료
        {
            break;
        }
        else if (strcmp(str, "list") == 0)      // list를 입력하면 파일의 내용 확인
        {
            fseek(fp, 0, SEEK_SET);             // 버퍼의 위치 지시자를 맨 처음으로 이동
            while (1)
            {
                fgets(str, sizeof(str), fp);    // 과일 이름을 읽는다.
                if (feof(fp))                   // 파일의 내용을 모두 읽으면 종료
                {
                    break;
                }
                printf("%s", str);              // 읽은 과일 이름을 화면 출력
            }
        }
        else
        {
            fprintf(fp, "%s\n", str);           // 입력한 과일 이름을 파일에 출력
        }
    }
    fclose(fp);

    return 0;
}
/* 처음 실행결과랑, 2번째로 실행했을때 list에 축적이 된다. 
최초 실행할때 파일이 없으면 빈 파일을 만들어서 출력하고 파일이 있으면 데이터를 추가하기 위해
a 모드를 사용한다. <또한> 데이터를 기록 중에 언제든지 파일의 내용을 다시 읽어서 확일할수
있도록 + 모드를 함께 사용한다.
입력한 과일 이름이 21행의 end와 25행의 list와 같지 않으면 40행에서 개방한 파일에
과일 이름을 계속 출력한다.

이때 필요한 작업, 파일의 입력과 출력을 서로 전환할 때마다 fseek 함수를 호출해야 한다.
40행의 fprintf 함수는 스트림 파일의 버퍼에 데이터를 출력해놓는데, 이때 버퍼에 데이터가 있는
상태에서 바로 하드디스크로부터 데이터를 입력하게 되면 입출력 순서가 꼬인다.
<따라서> 버퍼의 데이터를 하드디스크로 옮기고 버퍼를 읽기 위한 공간으로 설정한 후에
하드디스크의 데이터를 처음부터 다시 읽도록 해야 한다.

fseek 함수 원형
int fseek(FILE * stream, long offset, int whence);
각 인수를 보면 첫 번째 인수인 stream 파일의 버퍼에서 whence를 기준으로 offset만큼
위치 지시자를 옮긴다. 위치 이동에 실패하면 0, 성공하면 0이 아닌 값 반환

whence에 사용 할 수 있는 값과 의미
값      매크로명        기준 위치           오프셋 값
0       SEEK_SET        파일의 처음         양수만 가능
1       SEEK_CUR        파일의 현재 위치    양수와 음수 모두 가능
2       SEEK_END        파일의 끝           음수만 가능

예로들어 fseek(fp, -5, SEEK_END);는 파일의  끝에서 다섯 문자 앞으로 위치 지시자를 
옮긴다. 매크로명은 값 대신에 사용할 수 있는 이름으로써 전처리 과정에서 약속된
정수로 바꾼다. <결국> 27행의 fseek 함수는 스트림 파일의 위치 지시자를 시작 위치로 옮기며
그 전에 버퍼의 내용을 하드디스크로 출력한다. <이때> rewind 함수를 사용하면 편하다.
fseek(fp, 0, SEEK_SET); --> rewind(fp);

이후 30행의 fgets 함수는 비어진 버퍼를 사용하여 하드디스크에서 데이터를 처음부터 입력한다.
파일로부터 데이터를 읽다가 중강네 다시 출력하려면 역시 fseek 함수를 호출한다.
<다만> 파일의 끝까지 모두 읽고 나서 쓰기로 바꾸는 fseek 호출 없이 바로 출력이 가능하다.
어떤 경우든 a+모드에서 출력하는 데이터는 항상 파일의 맨 뒤에 붙여넣기가 된다.
반면에 w+ 모드는 데이터를 읽다가 중간에 다시 쓰는 경우 fseek 함수로 설정한 위치부터
내용을 덮여쓴다.

r+ 모드는 읽기를 먼저 하든 쓰기를 먼저 하든 상관없지만, 읽기와 쓰기를 서로 바꿀때는
fseek 함수로 파일에서 일고 쓸 위치를 알려주어야 한다. 파일을 열자마자 데이터를 출력하면
파일의 내용을 앞에서부터 덮어쓰며, 파일을 끝까지 다 읽은 후에 출력하면 fseek 함수 호출 없이
바로 이어서 출력할 수 있다.

31행의 feof 함수는 스트림 파일의 데이터를 모두 읽었는지 확인할 때 유용하다. 파일의 끝이면
0이 아닌 값을 반환하고, 끝이 아니면 0을 반환하므로 반환값의 부정이 참이면 파일의 끝이 아님을
알수 있다. feof 함수는 입력 함수가 데이터 입력에 실패한 이후에 그 결과를 알 수 있으므로
입력함수 다음에 사용한다.
if (feop(fp))       // 31행, 파일의 내용을 모두 읽으면 종료
{
    break;
}

개방모드                    파일이 있을때
r+          텍스트 파일에 읽고 쓰기 위해 개방
w+          텍스트 파일의 내용을 지우고 읽거나 쓰기 위해 개방
a+          텍스트 파일을 읽거나 파일의 끝에 추가하기 위해 개방
rb+         바이너리 파일을 일고 쓰기 위해 개방
wb+         바이너리 파일의 내용을 지우고 읽거나 쓰기 위해 개방
ab+         바이너리 파일을 읽거나 파일의 끝에 추가하기 위해 개방
*/
