// 버퍼를 공유하므로 생기는 문제
#include <stdio.h>

int main(void)
{
    FILE *fp;       // 파일 포인터
    int age;
    char name[20];

    fp = fopen("a.txt", "r");       // 파일 개방

    fscanf(fp, "%d", &age);         // 나이 입력
    fgets(name, sizeof(name), fp);  // 이름 입력

    printf("나이 : %d, 이름 : %s", age, name);      // 입력 데이터 출력 
    fclose(fp);     // 파일 닫음

    return 0;
}
/* 실행 결과는 나이만 입력되어 나온다. 이런 현상은 fscanf와 fgets 함수가 개행문자를
처리하는 방식이 달라서 나온 현상이다. <즉> 12행의 fscanf 함수가 나이를 입력한 후에
버퍼에 남겨놓은 개행 문자를 다음에 호출되는 fgets 함수가 이어서 입력하기 때문이다.
fgets 함수는 개행문자가 나올 때까지 문자열을 입력하는데 처음부터 개행문자가 있으므로
개행문자만 입력한다. <따라서> 이름을 추가로 입력하지 못하고 프로그램이 끝난다.

(해결법) 화이트 스페이스(개행, 공백, 탭)를 데이터로 입력하지 않고 건너뛰는 함수를 쓰면
해결된다. <즉> 이름을 입력할 때 fscanf(fp, "%s", name);을 사용한다.
    <그러나> 이 경우 fscanf 함수가 공백을 입력 데이터를 구분하는 용도로 사용하므로
    이름으로 "Hong"만 입력하는 문제가 생긴다.
    <따라서> fgetc 함수를 12행과 13행 사이에 끼워 넣어 스트림 버퍼에서 개행문자를 읽어
    반환하여 그 값은 별도로 사용되지 않으면 버려집니다.

    상황에 따라 버퍼에서 개행문자 하나만 제거한다고 안끝나는 경우도 있다.
    예로 들어 데이터 파일이 다음과 같을 때 첫 행에서 정수부분만 나이로 입력한다면
    나이의 제외한 나머지 부분은 이름을 입력하기 전에 버퍼에서 제거해야 한다.
    17 years old\nHong GD
    17 --> fscanf 함수 입력
    years old\n --> 개행 문자까지 제거
    Hong GD --> fgets 함수 입력

    이경우 반복문을 쓰거나 함수로 만들어 사용한다.
    while (fgetc(fp) != '\n') {}    // fgetc 함수의 반환값이 개행 문자가 아닌 동안 반복
    void my_fflush(FILE *fp)        // 스트림 버퍼에서 개행문자까지 데이터를 읽어 제거
    {
        whlie (fgetc(fp) != '\n') {}
    }
<또한> 스트림 파일의 버퍼를 지우는 fflush 함수를 생각할수 있다.
fflush 함수 원형
int fflush(FILE *);     // 인수는 스트림 파일의 포인터

fflush 함수는 파일 포인터를 인수로 주면 파일 포인터와 연결된 스트림 파일의 버퍼를 비운다.
반환값은 0이며 버퍼를 비우지 못했을 때는 EOF를 반환한다. fflush 함수를 사용하여
버퍼의 불필요한 데이터를 모두 지우면 좋다. <그러나> 12행과 13행 사이에 fflush(fp);
문장을 넣으면 개행 문자를 포하하여 버퍼에 입력된 이름도 모두 지워진다. <따라서>
fflush 함수는 입력 파일에 대해서는 표준이 정의되어 있지 않고 사용하면 시스템에 따라
변화가 없거나 컴파일 에러가 나기도 한다. <단> 출력 파일에 사용하면 버퍼를 비우면서
남은 데이터를 연결한 장치로 바로 출력한다. <만약> 출력 함수를 호출한 후에 버퍼의
데이터를 즉시 하드디스크와 같은 장치로 저장해야 한다면 fflush 함수를 사용할 수 있다.
*/