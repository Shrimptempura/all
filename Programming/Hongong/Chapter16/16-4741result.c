#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int num;
    int *ap;
    int i, j, cnt = 0;

    printf("> 양수 입력 : ");
    scanf("%d", &num);

    ap = (int *)malloc((num - 1) * sizeof(int));
    // 1차원 배열의 사이즈를 동적할당 하는 것인데, 여기서 (num -1)은 세부조건
    // 입력값 -1개의 배열의 크기가 필요한것

    if(ap == NULL)  // 동적할당 오류 확인용 간단 ㅇㅋ?
    {
        printf("메모리 부족...\n");
        exit(1);
    }

    for(i = 0; i < (num - 1); i++)
    // 2부터 시작하니까 (num - 1)한것
    {
        ap[i] = i + 2;
        // 첫째행이 ap[0] 일때 2라구~
    }

    i = 0;  // 다시 i 0으로 초기화
    while(1)
    {
        while((ap[i] == 0) && (i < (num - 2)))
        // 소수점 찾기 방법, 아리스토 텔레스의 채 방법, ap[i] == 0 일때는 아리스토
        // 방법에서 나눠서 떨어지면 소수가 아니기 때문에 조건문임
        // i < (num - 2)는 맨 마지막에는 (소수찾기) 나눌 방법이기 때문
        // 하나가 나눌필요가 없다
        {
            i++;
            // 소수인 숫자(여기서는 0으로 대입)가 나오면 인덱스 한칸 옮기기
        }

        if (i == (num - 2)) break;
        // 맨 마지막 숫자에 도달하면 종료
        for(j = i + 1; j < (num - 1); j++)
        // i가 0이면 j는 1임, j는 나눠지는 인덱스를 표시
        // (num - 1)은 마지막까지를 뜻함
        {
            if((ap[j] % ap[i]) == 0)
            // ex) 2를 3으로 나누는데 0이 나오면, i = 2, j = 3
                {
                    ap[j] = 0;
                    // 0 대입
                }
        }
        i++;
        // 배열로 쭉 나누고 다시 i증가해서 while 돌림
    }

    for(i = 0; i < (num - 1); i++)
    // 0부터 맨끝짜리까지
    {
        if(ap[i] != 0)
        // 0이 아닐때만 출력해라 그 값음 ap[i]
        {
            printf("%5d", ap[i]);
        }
        else
        {
            printf("%5c", 'X');
            // 그렇지 않으면 "X" 출력
        }

        if((i + 1) % 5 == 0)
        // 5개씩 나누는 개행 조건
        {
            printf("\n");
        }
    }
    free(ap);
    // 동적 할당 해제 선언

    return 0;
}
/* 일단 문제의 핵심인 소수 찾기의 알고리즘을 알지 못했다.
그리고 나는 또 출력 "결과"만 보고 2차원 배열 동적할당을 사용했는데 이것도
전전 문제의 영향임, 사실 문제는 배열에 1씩 증가되는 정수를 소수를 찾은후
5개마다 개행때리면 되는 문제였다.. +기타 세부조건 2부터 증가, ~ 입력값 -1까지 */