// [average 함수 정의]
extern int count;           // 19-1.c의 전역 변수 count 공유
extern int total;           // 19-91.c의 전역 변수 total 공유

double average(void)
{
    return total / (double)count;       // 입력값의 평균 반환
}
/*
이 예제는 4개의 함수를 3개의 파일로 나누어 작성했다.
<19-9.c> 파일
    main 함수 : input_data, average, print_data 함수를 호출합니다.
    print_data 함수 : 입력한 양수의 개수, 전체 양수의 합과 평균을 출력합니다.

<19-91.c> 파일
    input_data 함수 : 음수가 입력될 때까지 양수를 반복 입력하여 그 합을 반환합니다.

<19-92.c> 파일
    average 함수 : 입력한 양수의 평균을 구해 반환합니다.

<또한> 함수 간의 데이터 공유를 위해 전역 변수를 사용합니다. 먼저 19-9.c 파일의
13행(int count = 0;(전역변수))는 입력한 양수의 개수를 저장하므로 input_data 함수에서 쓰고
평균을 구하거나 출력할 때도 필요합니다. <즉> 모든 함수에서 필요하므로 전역변수로 선언하여
쉽게 공유하고자 합니다. <따라서> 같은 파일에 있는 print_data 함수는 29행(printf에서 count변수
사용)같이 count를 직접 사용하여 출력할 수 있다.
    <그러나> 다른 파일에 있는 함수가 count를 직접 사용할때 문제가 발생한다.

    컴파일러는 소스 파일 단위로 컴파일하므로 다른 파일에 선언된 전역 변수를 알지 못한다.
<즉> 19-91.c 파일을 컴파일 할때 16행(count++)가 19-9.c에 있는 전역 변수임을 알지 못합니다.
이 경우 4행(extern int count;)이 필요하다. extern 선언은 변수가 다른 파일에 있음을 알리기만
할뿐 새로운 전역 변수를 만드는 것은 아니다. <따라서> count가 필요한 파일은 모두 extern 선언
으로 전역 변수를 공유할 수 있다. average 함수도 입력한 값의 평균을 구하기 위해 count가 필요
하므로 19-92.c 파일의 2행에서 extern 선언을 하여 7행에서 count를 사용한다.

<만약> extern선언 안하고 각각 전역 변수로 파일마다 선언하면 하나의 독립적으로는 컴파일은 되나
링크단계에서 오류 발생, 같은 이름이 중복되어 19-92.c 의 extern선언은 어떤 파일의 전역변수를
공유하는지 알수 없기 때문이다.

- 컴파일러가 둘 이상의 같은 파일에 같은 이름의 전역 변수 허용하는 경우
        = 가능은 하나 오류 개많다. 명시적으로 extern 사용하자

- 컴파일러가 extern 선언에 초기화 하는 경우
        = extern 선언은 저장 공간을 메모리에 할당하지 않으므로 초기화 할 수 없다.
        만약 초기화 허용하는 컴파일러는 extern 선언을 독립된 전역 변수의 선언으로 간주하고
        변수의 저장 공간을 할당한다. 이때 초기화된 같은 이름의 전역 변수가 다른 파일에 
        있으면 링크과정에서 중복 문제가 발생한다. 또한 컴파일러마다 다르므로 
        <결국> extern 선언을 한 경우 초기화는 하지 말자

전역 변수에 static을 붙이면 하나의 소스 파일에서만 사용할 수 있다.

19-9.c 파일의 14행(static int total = 0;)에 선언한 total은 정적 전역 변수이므로
같은 파일에 있는 main 함수와 print_data 함수만 사용할 수 있다. <또한> 19-91.c의 5행(int total
= 0;)과 같이 다른 파일에 같은 이름의 전역 변수를 선언하는 것도 가능하다. 이 경우 별도의 
저장 공간을 갖는 전역 변수가 선언되며 19-92.c의 3행(extern int total;)과 같이 다른 파일에서
extern 선언을 통해 공유할 수 있다.

정적 전역 변수는 하나의 파일에서만 사용하고 다른 파일과는 공유를 차단하므로 다른 파일에서
같은 이름의 전역 변수를 사용할 수 있는 장점이 있다. <또한> 사용 범위를 하나의 파일로
제한하므로 데이터를 보호할때 유용하다. 예로 중요 데이터를 정적 전역 변수로 선언하고
하나의 독립된 파일로 작성하면 다른 파일에서 임의로 수정하는 것이 불가능하다.

변수뿐만 아니라 함수에 static 예약어를 사용하면 함수를 정의한 소스 파일에서만 사용할 수 있다.
    static int input_data(void) {}.. -> 다른 파일에서 호출 불가

함수에 static을 사용하지 않으면, 함수 선언은 기본적으로 extern 선언으로 간주된다.
따라서 extern 없이 원형 선언만으로 다른 파일의 함수를 호출 할수 있다(분할 컴파일 시)
<단> 다른 파일에 있는 함수임을 명시적 표현하기 위해 extern을 붙이기도 한다.
*/


