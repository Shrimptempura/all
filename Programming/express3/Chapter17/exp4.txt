<자기 참조 구조체> self-referential structure
특별한 구조체로서 구성 멤버 중에 같은 타입의 구조체를 가리키는 포인터가 존재하는
구조체이다.

struct NODE {
    int data;
    struct NODE *link;      // 현재 구조체를 가리킬 수 있는 포인터
};

자기 참조 구조체는 포인터를 이용하여 다른 구조체와 연결될 수 있다. (연결리스트나 트리..등)
일반적으로 항목의 개수를 미리 예측할 수 없는 경우에 자체 참조 구조체를 정의해 놓고
동적으로 기억 장소를 할당받아서 이들을 포인터로 연결하여 자료 구조를 구성한다.
    자기 참조 구조체를 포인터로 연결하여 자료를 저장하게 되면 중간에
    새로운 자료를 삽입하기가 용이하다.

보통 자기 참조 구조체는 typedef을 이용하여 새로운 타입으로 정의하는 것이 보통이다.
typedef을 이용하게 되면 매번 struct 키워드를 써주지 않아도 된다.

<연결 리스트 생성의 예>
(두개의 자기 참조 구조체 연결 예시..)

node1 -> node2 -> NULL
    : 자기 참조 구조체의 포인터 값이 NULL이면 다른 구조체를 가리키지 않는다.

typedef struct NODE {
    int data;
    struct NODE *link;
} NODE;

    노드의 구조는 정의되었으나 아직 노드는 생성되지 않음
    일반적으로 연결 리스트에서는 필요할 때마다 동적 메모리 할당을 이용하여
    노드를 동적으로 생성한다.

    다음 코드에선 포인터 변수 p1을 만들고 malloc()을 이용, 노드의 크기만큼
    동적 메모리를 할당 받는다. 이 동적 메모리가 노드가 되는 것이다.

    NODE *p1;
    p1 = (NODE *)malloc(sizeof(NODE));

    다음은 새로 만들어진 노드에 데이터를 저장하고 링크 필드를 NULL로 설정

    p1 -> data = 10;
    p1 -> link = NULL;

    일반적으로 연결 리스트에는 여러 개의 노드가 서로 연결되어 있다. 따라서
    똑같은 방법으로 두 번째 노드도 역시 동적 생성하고, 첫 번째 노드의 링크 필드가
    두 번째 노드를 가리키도록 하여 두 개의 노드를 서로 연결하자

    NODE *p2;
    p2 = (NODE *)malloc(sizeof(NODE));
    p2 -> data = 20;
    p2 -> link = NULL;
    p1 -> link = p2;

    노드를 더 생성하고 싶은 이상의 과정을 원하는 만큼 반복한다.
    주의 점은 동적 메모리 할당을 이용했기 때문에 반드시 끝에 해제를 해야 한다.

    free(p1);
    free(p2);

    보통 연결 리스트에 삽입과 삭제하는 함수를 따로 작성하여 이 함수를 호출하여
    노드 삽입과 삭제를 수행하는 것이 보통이다.