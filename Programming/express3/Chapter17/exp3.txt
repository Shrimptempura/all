동적으로 1차원 배열은 생성할 수 있으나, 2차원 배열은 불가능하다.
하지만 2차원 동적 배열을 작성 할 수 있다.

가장 일반적인 방법은 이중 포인터 배열을 만들고 각 포인터가 동적 할당된 메모리를
가리키도록 초기화하는 것이다.

(간단 예제)
int **image = malloc(rows * sizeof(int *));
for (i = 0; i < rows; i++)
    image[i] = malloc(columns * sizeof(int));

// 2차원 배열의 사용
image[0][0] = 255;
...

<연결리스트>
배열의 장점 : 구현이 간단하고 빠르다.
       단점 : 크기가 고정되며 동적으로 크기가 늘어나거나 줄어들 수 없다.
    
    따라서 만약 데이터를 추가하고 싶은데 더 이상 남은 공간이 없으면 문제가 발생
    (물론 더 큰 배열을 만들어서 기존 배열 데이터를 복사할 수 있지만 이건 많은
    CPU 시간을 낭비하며 중간에 새로운 데이터를 삽입하거나 삭제하기 위해 기존의
    데이터를 이동하여야 한다.)

연결 리스트는 각각의 원소가 포인터를 사용하여 다음 원소의 위치를 가리킨다.
연결 리스트에서 삽입 삭제시 앞뒤 데이터를 이동할 필요 없이 줄만 변경시키면 된다.

또다른 장점으로는 데이터를 저장할 공간이 필요할 때마다 동적으로 공간을 만들어서
쉽게 추가할 수 있다. (배열에 비하여 상당한 장점)

    그러나 배열에 비해 상대적 구현이 어렵고 오류가 나기 쉽다.

<연결리스트의 구조>
한 상자 (노드라고 불림)
상자 안에는 데이터 필드(data field)와 링크 필드(link field)로 이루어져 있음

데이터 필드에는 우리가 저장하고 싶은 데이터가 들어있다.
정수나 구조체 등 복잡한 데이터 가능

링크 필드에는 다른 노드를 가리키는 포인터가 저장된다.
이 포인터를 이용하여 다음 노드로 건너갈 수 있다
    연결리스트의 첫번째 노드를 알아야 시작이 가능한데
    이를 헤드 포인터(head pointer)라고 한다.

연결 리스트는 노드가 하나도 없으면 헤드 포인터는 NULL값을 가지며 
공백 연결 리스트라고 불린다.

연결 리스트의 마지막 노드의 링크 필드는 NULL으로 설정되며 이는 더 이상
연결된 노드가 없다는 것을 의미한다.


연결 리스트에서 노드들은 메모리상의 어떤 곳에나 위치 할 수 있다.
즉, 노드들의 순서가 리스트상의 순서와 동일하지 않을 수 있다는 특성을 가진다.
    연결 리스트를 사용하면 연속적인 기억공간이 없어도 데이터 저장이 가능하며
    미리 기억공간을 확보할 필요도 없다. 필요할 때마다 노드를 동적으로 생성하여 연결한다.

단점으로는
    1) 링크 필드를 위한 추가 공간이 필요하며
    2) 배열에 비해 구현이 복잡해짐 -> 에러 가능성 올라감