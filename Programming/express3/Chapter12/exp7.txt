<잘못된 경우>
char *s;
if (s == "langauge")

    c언어는 문자들의 배열로 문자열을 나타낸다. c에서는 배열 전체를 다른 배열과 하나의
    연산자로 비교, 대입 할 수 없다. 위는 포인터 s의 값과 "langauge"가 저장된 주소를 
    비교한다. 대부분의 경우 같은 위치를 가리킬 수가 없으므로 위의 식은 항상 같지 않다고
    결과가 나온다.
        두개의 문자열을 비교하려면 반드시 strcmp()를 사용해야 한다.

<다음 문장이 오류를 발생하는 이유>
char *p = "Hello World";
p[1] = NULL;

    위의 선언의 경우, 문자 배열이 생성되는 것이 아니라, 문자열 상수가 저장되고, 이 문자열
    상수의 주소만 포인터 p가 가지고 있다. 그리고 문자열 상수는 대개 읽기 전용 메모리 공간
    에 저장되므로 p를 가지고 문자열을 수정하려고 하면 실행 오류가 발생한다.

<다음 문장이 오류를 발생하는 이유>
char s[100];
s = "A friend in power is a friend lost";

    c에서는 문자열은 배열에 저장되고, 배열 전체에 어떤 값을 대입할 수 없다.
    반드시 strcpy()를 사용해야 한다.
    => strcpy(s, "A ~ lost");

<다음 문장이 오류를 발생하는 이유>
char *dst = "A friend in power";
char *src = "is a friend lost.";
strcat(dst. src);

    strcat()으로 이어 붙이는데 dst는 반드시 추가 공간을 가지고 있어야 한다.
    하지만 위의 코드는 dst이 가리키는 주소에는 문자열 상수가 저장되어 있고
    따라서 더 이상의 추가 공간을 가지고 있지 않다.
    => char dst[100] = "A friend in power"; (수정)

<두가지 문장의 차이점>
char s[] = "A friend in power";
char *p = "A friend in power";

    1)은 문자배열이 선언되고 문자 배열의 초기값이 "A friend in power"가 된다.
    2)는 문자열은 읽기전용 메모리에 상수로 저장되고, 이 문자열 상수의 주소가
    포인터 p에 대입된다.