<버퍼링>
스트림에는 기본적으로 버퍼(buffer)가 포함되어 있다. fopen()에 의하여 생성된 스트림은
입출력 시에 버퍼를 이용한다. 버퍼는 파일로부터 읽고 쓰는 데이터의 임시 저장 장소로
이용되는 메모리의 블록이다. 

버퍼가 있다면 출력 데이터는 일단 버퍼에 써진다. 버퍼가 다 채워지면 비로소 디스크 
파일에 버퍼의 내용을 기록한다. 입력 시에도 마찬가지다.

한 문자만 필요해서 입력을 요구했더라도 관련된 전체 블록을 읽어서 버퍼에 둔다. 만약
다음 문자가 필요하면 파일에서 읽지 않고 버퍼에서 읽어서 반환하게 된다.

버퍼를 두는 이유?
    디스크에서 물리적으로 데이터를 읽을 때는 상당한 시간이 걸리기 때문이다.
    따라서 한번 읽을 때 많이 읽어두고 나중에 다음 데이터가 필요하면 바로 버퍼에서
    갖다 주는 것이다. (ex: 치약 많이 사고 필요할때 사용)

    하지만 프로그램에 따라서 버퍼를 비워야 하는 경우는 자주 발생한다. 즉 프로그램이
    쓴 데이터가 즉시 하드웨어 장치에 써지기를 원한다면 버퍼를 비워야 한다. 버퍼는
    fflush()를 호출하면 비워진다. 버퍼의 내용이 디스크 파일에 써진다.
        fflush(fp);

    인수 fp는 FILE에 대한 포인터이다. 파일에서 읽을 때도 마찬가지이다. 기존에 버퍼에
    있던 것을 무시하고 새로 읽을려면 fflush()를 호출한다. fflush()가 호출되면 파일이
    읽기 모드로 열려있는 경우, 버퍼는 단순히 비워진다. 파일이 쓰기 모드로 열려있는 경우
    버퍼의 내용이 디스크에 기록된다.

    버퍼는 유용하지만, 버퍼가 있으면 안되는 경우가 있다
    예로 장치나 파일을 직접적으로 제어할 필요가 있거나, 많은 양의 이진 데이터를 쓰거나
    읽을 경우 오히려 버퍼가 없는 것이 편하다.

    만약 입출력에서 버퍼를 제거하려면 setbuf() 함수를 사용한다. setbuf()는 스트림의
    버퍼를 직접 지정하는 함수로서 만약 버퍼 자리에 NULL을 써주면 버퍼를 제거하겠다는
    것을 의미한다.
        setbuf(fp, NULL);
    
    그러나 일반적으로 버퍼가 없는 입출력의 경우, 입력과 출력을 할 때마다 시스템 호출이
    필요하므로 속도가 매우 느려지고 비효율적이다. 
