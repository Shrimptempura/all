<ASSERT 매크로>
- 전제 조건 검사 사용, 가정이 잘못된 경우, ASSERT는 __LINE__과 __FILE__ 내장 매크로를
이용하여 소스 파일의 이름과 행번호를 출력하고 종료하게 된다.

    >> 실행결과
    가정(sum == 0)이 소스 파일 c:user\igchu\.....
    23번째 줄에서 실패

#include <stdio.h>
#define ASSERT(exp) {if(!(exp)) \
        {printf("가정(" #exp ")이 소스 파일 %s %d번째 줄에서 실패.\n"\
        ,__FILE__, __LINE__), exit(1);}}

int main(void)
{
    int sum = 100;

    ASSERT(sum == 0);   // sum의 값이 0인지를 확인한다.
    return 0;
}

매크로를 함수대신 사용하면 장점과 단점
장점) 함수 매크로는 함수에 비하여 수행 속도가 빠르다.
      매크로는 호출이 아니라 코드가 그 위치에 삽입되는 것이기 때문에 함수 호출의
      복잡한 단계를 거칠 필요가 없다.
        실제 함수 호출을 하기 위해서는 인수와 복귀 주소를 시스템 스택에 저장해야 한다.
        매크로는 이러한 절차들이 전혀 필요 없다. 따라서 실행 속도가 빠르다.

단점) 코드의 길이를 어느 한도 이상 길게 할 수 없다.
      많은 경우 한줄.. 두 세줄이 한계이다.
        또한 매크로는 전처리기가 발견될 때마다 매크로의 정의 부분에 있는 코드가 확장
        하므로 소스의 길이가 길어진다.
        만약 30개의 매크로가 있다면 30개의 똑같은 코드가 프로그램에 존재한다.
            함수는 다 하나의 코드만을 가지고 있다. 따라서 매크로를 사용하면 
            소스 파일의 크기가 커진다.

따라서 함수 매크로와 함수중 무얼 사용할 지는
    프로그램의 크기와 실행 속도 중에서 어떤 것이 더 중요한지를 따져보아야 한다.

- 일반적 기준으로는 다음과 같은 간단한 기능은 함수보다 매크로를 사용하는 편이 좋다.
#define MIN(x, y) ((x) < (y) ? (x) : (y))
#define ABS(x) ((x) > 0 ? (x) : -(x))

    만약 매크로가 전체 프로그램을 통하여 한번만 사용된다면 큰 효과를 기대하기 힘들다
    하지만 매크로가 중첩 반복 루프 안에 위치했다면 실행 속도가 개선될 가능성이 많다.