<비트 필드 사용시 주의점>
비트 필드를 사용할 때에 비트 필드 멤버의 이름은 생략이 가능하다. 이때는 해당 비트를
사용할 수 없으며 단지 자리만 차지하게 된다.
struct product {
    unsigned style : 3;
    unsigned size : 2;
    unsigned color : 1;
    unsigned : 2;       // 이름은 없고 자리만 차지하는 비트 필드를 둘 수 있다.
};
이러한 비트 필드가 필요한 이유
    - 워드의 경계에 비트 필드가 걸치게 되면 입출력 속도가 상당히 늦어지기 때문에
      다음 멤버가 워드의 처음에서 시작할 수 있도록 이러한 필드를 두는 것

이름이 없는 비트 필드 중에서 크기가 0인 비트 필드를 둘 수 있다. 이때는 그때까지
사용하지 않은 현재 워드의 남아 있는 비트들을 모두 버린다. 이는 다음 비트 필드가
워드의 처음에서 시작하도록 만들기 위해서이다.
struct product {
    unsigned style : 3;
    unsigned : 0;       // 현재 워드에 남아 있는 비트를 버린다.
    unsigned size : 2;
    unsigned color : 1;
};  // 첫 번째 워드의 하위의 3비트를 style이 사용하고 나머지 비트들은 모두 버려진다.
    // 다음 워드에서 size와 color는 할당된다.


또한 비트 필드의 크기를 지정할 때에 워드의 크기를 넘어설 수 없다.
(비주얼 C++ 워드의 크기 : 32) 따라서 32 오버는 오류
struct product {
    unsigned style : 3;
    unsigned size : 34;     // 32 보다 큼
    unsigned color : 1;
};

비트 필드 구조체 안에 일반 멤버도 같이 선언할 수 있다.
즉 구조체 안에 비트 필드 멤버와 일반 멤버를 동시에 둘 수 있다.
struct product {
    int number;     // 일반 멤버
    unsigned style : 3;
    unsigned size : 2;
    unsigned color : 1;
};

<비트 필드의 응용 분야>
목적1) 데이터를 저장할 때 저장 장소를 절약하기 위해서이다
    : ON 또는 OFF의 상태만 가지는 변수를 저장할 때 32비트의 int형 변수를 사용하는
      것보다 1비트 크기의 비트 필드를 사용하는 편이 훨씬 메모리를 절약한다.

목적2) 비트 필드가 많이 사용되는 분야는 하드웨어 제어.
    : 하드웨어 장치들은 비트 단위로 제어하도록 되어 있다.