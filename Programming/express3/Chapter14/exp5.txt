<다차원 배열과 포인터>
int m[3][3];
2차원 배열을 메모리에 저장하려면
    1) 행우선 방법(row-major)
    2) 열우선 방법(column-major)

    c에서는 행우선 방법이 사용된다. m[0], m[1], m[2]은..
    m[0]은 0번째 행의 시작주소와 같다. m[1]은 1번째 행의 시작 주소와 같으며
    m[2]는 2번째 행의 시작 주소와 같다..

<multi_array.c>     다차원 배열과 포인터
#include <stdio.h>

int main(void)
{
    int m[3][3] = {10, 20, 30, 40, 50, 60, 70, 80, 90};
    
    printf("m = %p\n", m);          // 배열의 시작 주소
    printf("m[0] = %p\n", m[0]);    // 0행의 시작 주소
    printf("m[1] = %p\n", m[1]);    // 1행의 시작 주소
    printf("m[2] = %p\n", m[2]);    // 2행의 시작 주소

    printf("&m[0][0] = %p\n", &m[0][0]);
    printf("&m[1][0] = %p\n", &m[1][0]);
    printf("&m[2][0] = %p\n", &m[2][0]);

    return 0;
}
    - 실행 결과
    m = 1245020         // 먼저 m의 값을 출력했다. m의 값이 &m[0][0]와 같은걸 알수 있다.
    m[0] = 1245020      // 또한 m[0], m[1], m[2]의 값이 &m[0][0], ...와 같음을 알수있다.
    m[1] = 1245032
    m[2] = 1245044
    &m[0][0] = 1245020
    &m[1][0] = 1245032
    &m[2][0] = 1245044

<다차원 배열의 이해>
그림 참조       ||은 묶음임.
    m ->    |m[0]|    ->   |m[0][0], m[0][1], m[0][2]|
            |m[1]|    ->   |m[1][0], m[1][1], m[1][2]|
            |m[2]|    ->   |m[2][0], m[2][1], m[2][2]|

<다차원 배열에서의 포인터 연산>
1차원 배열과 마찬가지로 다차원 배열에서도 포인터에 대하여 덧셈 연산이나 뺄셈 연산을
할 수 있다.     int m[3][3];
    구체적으로 m + 1은 무엇을 가리키고 m + 2는 무엇을 가리킬까?
    배열 m은 세 개의 원소 m[0], m[1], m[2]로 되어 있는 배열을 가리킨다고 생각할수있다.
    m에다가 1을 더하는 것은 하나의 원소의 크기만큼 이동하는 것이다.

    따라서 m이 m[0]을 가리키므로 m + 1은 m[1]을 가리키게 된다. m + 2는  m[2]와 같다.

<포인터를 이용한 다차원 배열 운행>
int m[4][3] = { {10, 20, 30}, {10, 20, 30}, ....};
1) 특정한 행의 원소들의 평균을 구하는 경우
    같은 행에 속하는 원소들은 순서대로 메모리에 놓여있다.
    --> 따라서 포인터를 이용하는 편이 효율적이다.
        먼저 포인터 p가 행의 첫 번째 원소를 가리키게 한다. endp는 행의 마지막 원소를
        가리키게 한다. 반복하면서 p가 가리키는 값을 sum에 합한 후에 p를 증가시킨다.
        p가 endp를 넘어가게 되면 반복을 중단한다.

1)
double get_row_avg(int m[ROWS][COLS], int r)
{
    int *p, *endp;
    double sum = 0.0;

    p = &m[r][0];           // p는 r행의 시작 주소
    endp = &m[r][COLS-1];   // endp는 r행의 종료 주소

    while (p <= endp)       // p가 종료 주소보다 작거나 같으면
        sum += *p++;        // sum에 p가 가리키는 값 누적

    sum /= COLS;            // 평균 계산

    return sum
}

2) 전체 원소들의 평균을 구하는 방법
int m[4][3] = { {10, 20, 30}, {10, 20, 30}, ....};
    먼저 포인터 p가 배열의 첫 번째 원소를 가리키게 한다. endp는 배열의 마지막 원소를
    가리키게 한다. 반복하면서 p가 가리키는 값을 sum에 합한 후 p를 증가시킨다.
    p가 endp와 같아지면 반복을 중단하면 된다.

2)
double get_total_avg(int m[][COLS])
{
    int *p, *endp;
    double sum = 0.0;

    p = &m[0][0];
    endp = &m[ROWS - 1][COLS - 1];

    while (p <= endp)
        sum += *p++;

    sum /= ROWS * COLS;

    return sum;
}