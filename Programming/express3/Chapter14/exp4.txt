<함수 포인터>
포인터는 변수 뿐만 아니라 함수도 가리킬 수 있다.
함수도 실행이 시작되는 주소를 가지고 있기 때문에 이 주소를 포인터에 넣을수가 있다.
포인터에 저장된 함수 주소를 이용하여 우리는 함수를 호출할 수 있다.
    함수를 가리키는 포인터 : 함수 포인터
    일반적인 포인터는 변수가 저장되어 있는 주소를 가리키지만 함수 포인터는 함수가
    시작되는 주소를 가리킨다.

변수를 가리키는 포인터는 int *p와 같이 가리키는 자료형만 알려주면 되지만
포인터를 이용하여 함수를 호출하려면 포인터가 함수를 가리킨다는 것을 알려줘야하고,
함수 호출에 필요한 인수, 반환형도 알려주어야 한다.

Syntax : 함수 포인터 정의
    int (*pf)(int, int);
    *pf : 함수를 가리키는 포인터를 선언한다.
            반드시 괄호가 필요하다. 괄호에 의하여 pf가 먼저 포인터가 되어야 한다.
    예) 정수형 매개 변수 두 개를 가지며 정수형을 반환하는 함수

함수 포인터가 함수를 가리키게 하려면 다음과 같이 함수의 이름을 포인터에 대입한다.
int sub(int, int);      // 함수 원형 정의
int (*pf)(int, int);    // 함수 포인터 정의
...
pf = sub;       // 함수의 이름을 함수 포인터에 대입

    위의 대입문은 함수 포인터 pf에 sub()의 시작 주소를 대입하는 것으로 이후부터
    pf가 sub()를 가리키게 된다. 함수의 이름은 배열의 이름과 마찬가지로 함수의
    시작 주소 나타내는 포인터 상수로 간주된다.
    따라서 배열의 경우와 마찬가지로 함수의 이름 앞에 &연산자를 사용할 필요가 없다.
    만약 반환형과 매개 변수만 일치하면 이름이 다르더라도 함수를 바꿔가며 가리킬수 있다.

        result = (*pf)(10, 20);
        (*pf)라는 표현이 약간 번거롭기 때문에 대부분 컴파일러에서는 pf를 함수 이름처럼
        사용해서 호출하는 것을 허용한다. pf는 어차피 함수 포인터라고 컴파일러가 
        알고 있기 때문에 (*pf)라는 표현대신 pf를 마치 함수이름처럼 사용해도 문제없다.

        result = pf(10, 20);

// fp1.c
#include <stdio.h>

int add(int, int);          // 41-42 함수 원형 정의
int sub(int, int);

int main(void)
{
    int result;
    int (*pf)(int, int);    // 함수 포인터 정의

    pf = add;               // 함수 포인터에 함수 add()의 주소 대입
    result = pf(10, 20);    // 함수 포인터를 통한 함수 add() 호출
    printf("10 + 20은 %d\n", result);

    pf = sub;               // 함수 포인터에 함수 sub()의 주소 대입
    result = pf(10, 20);    // 함수 포인터를 통한 함수 sub() 호출
    printf("10 - 20은 %d\n", result);

    return 0;
}

int add(int x, int y)
{
    return x + y;
}

int sub(int x, int y)
{
    return x - y;
}