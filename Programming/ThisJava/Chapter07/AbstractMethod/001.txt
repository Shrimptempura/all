<추상 메소드와 오버라이딩>
추상 클래스는 실체 클래스가 공통적으로 가져야 할 필드와 메소드들을 정의해 놓은
추상적인 클래스이므로 실체 클래스의 멤버(필드, 메소드)를 통일화하는데 목적이 있다.

모든 실체들이 가지고 있는 메소드의 실행 내용이 동일하다면 추상 클래스에 메소드를
작성하는 것이 좋다.

모든 동물은 소리를 내기 때문에..
Animal 추상 클래스에서 sound()라는 메소드를 정의했다고 가정
-> 동물은 다양한 소리를 내기 때문에 이것을 추상 클래스에서 통일적으로 작성할 수 없다.

 그렇다고 sound() 메소드를 실체에서 작성하도록 하면 sound() 메소드를 잊어버리고
 작성하지 않을 수도 있기 때문에 동물은 소리를 낸다는 것에 위배된다.

이런 경우를 위해서 추상 클래스는 추상 메소드를 선언할 수 있다.
추상 메소드는 추상 클래스에서만 선언할 수 있는데, 메소드의 선언부만 있고
메소드 실행 내용인 중괄호 {}가 없는 메소드를 말한다.

추상 클래스를 설계할 때, 하위 클래스가 반드시 실행 내용을 채우도록 강요하고 싶은
메소드가 있을 경우, 해당 메소드를 추상 메소드로 선언하면 된다.

자식 클래스는 반드시 추상 메소드를 재정의(오버라이딩)해서 실행 내용을 작성해야 하는데,
그렇지 않으면 컴파일 에러가 발생한다.
이것이 추상 메소드의 위력이다.
    (추상 메소드 선언)
    [public | protoected] abstract 리턴타입 메소드명(매개변수, ...);

일반 메소드 선언과의 차이점은 abstract 키워드가 붙어 있고 메소드 중괄호 {}가 없다.
다음은 Animal 클래스를 추상 클래스로 선언하고 sound() 메소드를 추상 메소드로
선언한 것이다.

    public abstract class Animal {
        public abstract void sound();
    }

어떤 소리를 내는지는 결정할 수 없지만, 동물은 소리를 낸다는 공통적인 특징이 있으므로
sound() 메소드를 추상 메소드로 선언했다.

Animal 클래스를 상속하는 하위 클래스는 고유한 소리를 내도록 sound() 메소드를 
재정의해야 한다.

예를 들어 Dog는 "멍멍", Cat은 "야옹" 소리를 내도록 Dog, Cat 클래스에서
sound() 메소드를 재정의해야 한다.


Animal / abstract sound();  소리낸다 : 어떤 소리인지 아직 모름
<- (inheritance) Dog, Cat
Dog / sound() { ... } 소리낸다 : 멍멍          Cat / sound() { ... } 소리낸다 : 야옹