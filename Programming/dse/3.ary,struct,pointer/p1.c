/*
배열의 요소         메모리 주소
list[0]             기본주소 = base
list[1]             base + 1 * sizeof(int)
list[2]             base + 2 * sizeof(int)

배열의 응용 : 다항식
    [1번째 방법]
ex) 10x^5 + 0 * x^4 + 0 * x^3 + 0 * x^2 + 6 * x + 3
(10, 0, 0, 0, 6, 3)을 배열 coef에 저장, 다항식의 차수는 변수 degree에 저장

        0   1   2   3   4   5   6   7   8   9   10
coef    10  0   0   0   6   3

#define MAX_DEGREE 101      // 다항식의 최대차수 + 1
typedef struct {
    int degree;
    float coef[MAX_DEGREE];
} polynomial;

polynomial a = {5, {10, 0, 0, 0, 6, 3}};

= 간단하고 쉽게 이해가 되나
    대부분의 항의 계수가 0인 희소 다항식의 경우에는 공간의 낭비가 심하다.

    [2번째 방법]
= 공간을 절약하기 위해 다항식에서 0이 아닌 항만을 하나의 전역 배열에 저장
    다항식의 0이 아닌 항들은 (계수, 차수)의 형식으로 구조체 배열에 저장
    ex) 10x^5 + 6x + 3      ==> ((10, 5), (6, 1), (3, 0))

#define MAX_TERMS 101
struct {
    float coef;
    int expon;
} terms[MAX_TERMS];
int avail;

A = 8x^3 + 7x + 1;      B = 10x^3 + 3x + 1;
        0   1   2   3   4   5   6   7   8   9   10
coef    8   7   1   10  3   1
expon   3   1   0   3   2   0

    = terms안에 항의 총 개수가 MAX_TERMS을 넘지만 않으면 많은 다항식을 저장할 수 있다.
    그러나 단점이 존재
    우선 하나의 다항식이 시작되고 끝나는 위치를 가리키는 인덱스 변수 관리
    또한 차수도 저장해야 하기 때문에, 다항식에 따라서는 계수만을 저장하는 첫 번째 방식보다
    공간을 더 많이 필요, 및 더 어려워짐

<두개의 다항식을 더하는 알고리즘>
두개의 다항식 A, B를 더하여 다항식 C를 구하려한다
- 순서대로 A와 B의 각 항의 차수를 비교하여, 차수가 같으면 A, B의 각 항의 계수를 더하여
    C로 옮기고, 차수가 다르면 A, B중에서 큰 항을 C로 옮긴다.
    이 과정을 어느 한쪽의 다항식이 끝날때까지 계속한다.
*/