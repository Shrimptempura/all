/* 이진 탐색 트리의 분석

이진 탐색 트리에서의 탐색, 삽입, 삭제 연산의 시간 복잡도는 트리의 높이를 h라고 했을때
-> O(h)가 된다. 따라서 n개의 노드를 가지는 이진 탐색 트리의 경우, 
일반적인 이진 트리의 높이는 [log2n]이므로 

이진 탐색 트리 연산의 평균적인 시간복잡도는 O(log2h)이다.

그러나 이는 좌우의 서브 트리가 균형을 이룰 경우이고 최악의 경우에는 한쪽으로 치우치는
경사 트리가 되어서 트리의 높이는 n이 된다. 이 경우에는 탐색, 삭제, 삽입시간이
거의 선형 탐색와 같이 O(n)이 된다.

따라서 선형탐색에 비하여 전혀 시간적으로 이득이 없다. 
따라서 이러한 최악의 경우를 방지하기 위하여 트리의 높이를 [log2n]으로 한정시키는 균형기법이 필요

<이진 탐색 트리의 응용: 영어사전>
이진 탐색 트리는 탐색을 위한 자료 구조이기 때문에 탐색이 효율적으로 될 것임을 기대할 수 있다.
가장 중요한 메뉴는 입력과 탐색, 삭제이다. 입력이 선택되면 사용자로부터 단어와 그 의미를
입력받아 insert_node 함수를 이용하여 이진 탐색 트리에 저장한다.
탐색이 선택되면 사용자로부터 단어를 입력받아 이진 탐색 트리에서 search 함수를 이용하여 탐색후,
그 의미를 화면에 출력한다. 삭제가 선택되면 delete_node 함수를 이용하여 입력된 단어를
찾아서 삭제한다.

여기서의 이진 탐색 트리에 저장되는 데이터는 정수가 아니다. 따라서 element 타입을 구조체로 정의하고
구조체 안에 우리가 필요한 필드들을 넣어야 한다. 필수적으로 영어단어와 그 의미가 각각 저장되어야 
하므로 우리는 두 개의 문자열 배열이 필요하다.

따라서 element 타입은 다음과 같이 word 배열과 meaning 필드를 가지도록 정의한다.
여기서 element 타입의 word 필드는 탐색의 기준이 되는 키 필드가 된다.
트리 노드도 element 타입을 데이터로 저장하도록 변경되었다.


#define MAX_WORD_SIZE 100
#define MAX_MEANING_SIZE 200

// 데이터 형식
typedef struct {
    char word[MAX_WORD_SIZE];   // 키 필드
    char meaning[MAX_MEANING_SIZE];
} element;
// 노드의 구조
typedef struct TreeNode {
    element key;
    TreeNode *left, *right;
} TreeNode;

추가로 두 개의 element 항목의 순서를 비교하는 함수 compare가 필요하다.
compare(e1, e2) 함수는 e1과 e2를 알파벳 순서로 비교하여 e1이 e2보다 작으면 -1,
같으면 0, 크면 1을 각각 반환한다. compare 함수는 strcmp 함수를 이용하여 구현되었다.

    만약 e1 < e2 이면 -1 반환
    만약 e1 == e2 이면 0 반환
    만약 e1 > e2 이면 1 반환

int compare(element e1, element e2)
{
    return strcmp(e1.word, e2.word);
}
*/