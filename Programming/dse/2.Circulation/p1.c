// 순환적인 팩토리얼 계산 프로그램
int factorial(int n)
{
    if (n <= 1) return (1);
    else return (n * factorial(n -1));
}

int factorial(3)
{
    if (3 <= 1) return (1);
    else return (3 * factorial(3 - 1));
}

/*
factorial(3) 수행중 factorial(2) 호출..
factorial(2) 수행중 factorial(1) 호출..
factorial(1)은 매개 변수 n이 1이므로 if절에 걸려 순환호출없이 1 반환

factorial(3) = 3 * factorial(2)
            = 3 * 2 * factorial(1)
            = 3 * 2 * 1
            = 3 * 2
            = 6

프로그래밍 언어에서 되풀이하는 방법은
반복(iteration)과 순환(recursion)이 있다.

반복)
    - for나 while 등의 반복구조로 되풀이
    - 간명하고 효율적으로 되풀이를 구현하는 방법
    - 때로는 반복을 사용시 지나치게 복잡해지는 문제 존재
        : 순환 -> 좋은 해결책

순환)
    - 일반적 순환은 함수 호출을 하게 되므로 반복에 비해 수행속도 면에서 떨어진다.
    - 물론 순환이 더 빠른 예제도 존재

factorial
    n != 1                                      if n = 0
    n != n * (n - 1) * (n - 2) * ... * 1        if n > 0
*/

// 반복적인 팩토리얼 계산 프로그램
int factorial_iter(int n)
{
    int i, result = 1;
    for (i = 1; i <= n; i++)
        result *= i;
    return result;
}

/*
문제의 정의가 순환적인 경우 순환으로 작성하는 것이 훨씬 쉽다. 
또한 대개 순환 형태의 코드가 더 이해하기 쉽다
그러나 순환적인 코드의 약점은 실행 시간이다.

순환은 알고리즘의 정의가 순환적으로 되어 있는 경우에 유리한 방법
ex) 팩토리얼 함수 계산, 피보나치 수열, 이항계수 계산, 이진 트리 알고리즘, 이진 탐색, 하노이 등

<순환 알고리즘 성능>
팩토리얼의 예에서 반복과 순환 알고리즘의 성능
반복 = for를 사용 n 반복, 시간복잡도 O(n)
순환 = 한번 순환 호출 할 때마다 1번의 곱셈 수행, 순환 호출은 n번, 시간복잡도 O(n)

반복과 순환 알고리즘 둘다 시간 복잡도는 같지만, 순환 호출의 경우 여분의 기억공간이 필요하고
또한 함수를 호출하기 위해서는, 함수의 매개변수들을 스택에 저장하는 것과 같은 사전 작업 상당 필요
-> 따라서 수행시간이 더 걸림

결론적)
    순환 알고리즘은 이해하기 쉽고 쉽게 프로그램가능 하지만, 수행 시간과 기억 공간의 사용에
    비 효율적
*/