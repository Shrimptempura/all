/*  연결리스트
[daat][link] ->

데이터필드 : 우리가 저장하고 싶은 데이터.. 정수, 구조체 등
링크 필드 : 다른 노드를 가리키는 포인터
헤드 포인터 : 첫번째 노드를 가리키는 변수
마지막 노드의 링크필드 : NULL
노드들은 필요할 떄마다 malloc()으로 동적 생성됨

연결리스트의 종류
1) 단순 연결리스트 : 마지막 노드 NULL, 하나의 방향으로 연결
2) 원형 연결리스트 : 마지막 노드의 링크가 첫 번째 노드를 가리킴
3) 이중 연결 리스트 : 각 노드마다 2개의 링크 존재, 양방향

노드는 어떻게 정의할 것인가? -> 자기 참조 구조체 이용
노드는 어떻게 생성할 것인가? -> malloc()을 호출하여 동적 메모리로 생성
노드는 어떻게 삭제할 것인가? -> free()를 호출하여 동적 메모리를 해제

<노드의 정의>
노드는 자기 참조 구조체를 이용하여 정의된다. 자기 참조 구조체란 자기 자신을 참조하는
포인터를 포함하는 구조체이다. 구조체 안에는 데이터를 저장하는 data 필드와 포인터가 저장되어있는
link 필드가 존재한다. data 필드는 element 타입의 데이터를 저장하고 있다. link 필드는 LinkNode를
가리키는 포인터로 정의되며 다음 노드의 주소가 저장된다.
*/
typedef int element;

typedef struct ListNode {
    element data;
    struct ListNode *link;
} ListNode;

/* 위 코드는 노드의 구조는 정의했지만 아직 노드는 생성하지 않았다.
ListNode를 가지고 실제 구조체를 생성할려면 구조체 변수를 선언하여야 한다.

<공백 리스트의 생성>
단순 연결 리스트는 헤드 포인터만 있으면 모든 노드를 찾을 수 있다.
따라서 다음처럼 노드를 가리키는 포인터 head를 정의하면 하나의 단순 연결 리스트라 볼수있다.
현재는 노드가 없으므로 head의 값은 NULL이 된다 */

ListNode *head = NULL;

/* <노드의 생성>
일반적으로 연결리스트에서는 필요할 때마다 동적 메모리 할당을 이용하여 노드를 동적 생성한다.
다음 코드에선 malloc() 함수를 이용하여 노드의 크기만큼 동적 메모리를 할당 받는다.
이 동적 메모리가 하나의 노드가 된다. 동적 메모리인 주소를 헤드 포인터인 head에 저장한다. */

head = (ListNode *)malloc(sizeof(ListNode));

// 위 코드가 실행되면, 아직 노드에는 아무것도 채워지지 않았다.
// head -> [][]

head->data = 10;
head->link = NULL;

// 위 절차는 새로 만들어진 노드에 데이터를 저장하고 링크필드를 NULL로 설정하는 것이다.
// head -> [10][NULL]

// <노드의 연결>
// 일반적인 연결리스트는 여러 개의 노드가 서로 연결되어 있다. 
// 두번째 노드를 동적 생성하고 노드에 20 저장

ListNode *p;
p = (ListNode *)malloc(sizeof(ListNode));
p->data = 20;
p->link;

// 1. head -> [10][NULL]        2. p -> [20][NULL]
// 생성된 2개의 노드를 연결해보자, head->link에 p를 저장하면
// 첫 번째 노드의 링크가 두 번째 노드를 가리키게 된다.

head->link = p;

// head -> [10][] -> [20][NULL]
// 노드를 더 생성하여 붙이고 싶으면 반복하면 된다.